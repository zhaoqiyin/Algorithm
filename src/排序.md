
### 计数排序
对员工年龄排序，因为年龄默认0-100，所以初始化一个101长度的队列（栈）然后
找出1个个数，2的个数，3个个数... 最后把这些数拿出来
比如 2个1，3个2，1个3...排序就是 1 1 2 2 2 3 ...

这种排序应用范围比较窄，只针对特定的数据状况


选择排序、冒泡排序、插入排序、归并排序、堆排序、快速排序都是针对比较的排序

其他的排序方式不是针对比较的排序，所以都限定特殊的数据。

上面的计数排序还可以优化一下，就是下面的基数排序

### 基数排序

只准备10个桶（针对10进制数），先把所有的数变成最大数的位数，比如最大数123是
3位数，则34变成034，不够3位数的前面用0补齐

先对数组中的每个数的个位数进行入桶（先入桶的先出桶），出后出桶，个位数小的
在前面，再对十位数入桶...,以此往复

### 排序总结
不具备稳定性的排序：

选择排序、快速排序、堆排序

具备稳定性的排序：

冒泡排序、插入排序、归并排序、一切桶排序思想下的排序

目前没有找到时间复杂度O(N*logN),额外空间复杂度O(1),又稳定的排序

基于比较的排序总结

|       |   时间复杂度   |  空间复杂度  | 稳定性 |
|:-----:|:---------:|:-------:|:---:|
| 选择排序  |  O(N^2)   |  O(1)   |  否  |
| 冒泡排序  |  O(N^2)   |  O(1)   |  是  |
| 插入排序  |  O(N^2)   |  O(1)   |  是  |
| 归并排序  | O(N^logN) |  O(N)   |  是  |
| 快排(随) | O(N^logN) | O(logN) |  否  |
|  堆排序  | O(N^logN) |  O(1)   |  否  |

经过实验，快速的时间常数项是最低的

排序用了3节课，该讲的都讲了

